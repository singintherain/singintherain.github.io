---
layout: post
title: Akka学习笔记
description: 本人接触的第一个并发框架
category: blog
---

## Actor Systems

每个Actor都是一个封装了状态和行为的对象，对象之间交互使用mailbox；
Actor比面向对象编程里面的对象要求更加严格，Actor System模型化了每个Actor相互交互的
方案，就好像一组人，每个人分配不同的子任务给他们，结构化的组织函数调用关系，并且
有任务失败处理机制;
这是一种新的软件设计思路，区别与现有的面向领域建模的方案。

### Actor

在Actor系统中，每个Actor都有一个管理者，它都是由其管理者创建出来的，因此整个系统
可以看成一个分层结构（我想应该是树状结构, 链式结构）

### 基本理念

将一个任务分成足够的小，使得能够分配给不同的Actor去执行; 这就要求，每个任务不仅要结构清晰，
而且还要定义出Actor之间如何使用message的方式来交互，还有每个Actor如何正常工作，
如果出现异常或者失败应该怎么办; 当一个Actor有自己无法处理的情况发生，它就会发送一个
失败消息给他的管理者，这样在管理链上依次传递这个错误消息，知道在指定的层次能够处理它。

### Actor标准

每一个Actor只会关心自己的工作，不会影响其他的Actor，避免独占资源；
采用事件驱动的方式来处理事件和产生响应；
每个Actor不应该被外部的实体所阻塞，如外部锁、网络socket等

在不同的Actor之间不要传递可修改对象，这要保证消息是不可变的。

Actor是动作和状态的容器

高层Actor是Error Kernel最核心的部分，在分层系统中需要谨慎对待；

### Blocking 管理

有些情况下不得不阻塞操作，如线程需要休眠多少秒，等待一个外部事件发生等；
阻塞一旦发生，在压力持续增加的情况下就可能造成内存泄露等问题，针对阻塞问题有以下建议：

* 在一个actor处理阻塞事件时，配置一个线程池
* 在一个Future中处理阻塞调用时，确保
* 用一个单线程中处理阻塞资源，例如NIO驱动，使用actor消息的方式分发事件

## Supervision管理机制

管理者: 代理task给它的下属节点, 并能够处理下属节点的失败事件

当一个actor发生了failure，例如抛出了异常，它会挂起自身及其所有的子节点，并发送失败信息
给它的管理者;管理者在收到错误信息后，它有以下四种可选的处理方式：

* 恢复子节点，保持他们的累积数据和内部状态
* 重启子节点，清空他们的累积数据和内部状态
* 永久性停止子节点
* 向他的上层报告错误，扩散错误

### Actor重启

actor在处理信息时，造成错误一般有三种情形：

* 消息获取系统级错误
* 外部资源临时性错误
* actor内部状态错误

重启的步骤：

* 挂起当前actor(不再处理消息直到回复)，递归挂起所有的子节点
* 调用旧actor实例的preRestart（默认是发送termination request给所有的子节点，并
调用postStop)
* 等待所有的子节点终止(context.stop())，这个是非阻塞的(?)，最后一个被杀死的节点的终止
消息会影响整个重启步骤到下一步
* 生成一个新的actor实例
* 调用postRestart
* 给所有的子节点发送restart request，
* 重新回复actor

### 生命周期监控DeathWatch

actor对外可见的状态就有两种：存活状态和死亡状态；监控就是将一个actor可另外一个相
关联，使得当一个actor终止的时候，另外一个能够发现并处理，
不同于actor的管理者处理失败的方式。

监控actor一般会接受到一个Terminated消息，默认的处理是抛出一个DeathPactException，
如果想在actor上开启对Terminated消息，使用ActorContext.watch(targetActorRef), 想
关闭对Terminated消息的监控，使用ActorContext.unwatch(targetActorRef)

监控在管理者想重启后者关闭子节点时非常重要，比如说actor在初始化的时候可能会出错，
监控能够保证可以监控到
