---
layout: post
title: 消息队列
description: 简单解释几种常见的消息队列机制
category: blog
---

消息队列现在是模块之间通信的非常通用的解决方案了。
消息队列使得进程间的通信可以跨越物理机，这对于分布式系统尤为重要，
毕竟我们不能假定进程究竟是部署在同一台物理机上还是部署到不同的物理机上。

目前业界有很多MQ产品，我们作如下对比：

## RabbitMQ

使用Erlang编写的一个开源的消息队列，本身支持很多的协议：AMQP，XMPP, SMTP, STOMP，
也正是如此，使的它变的非常重量级，更适合于企业级的开发。
同时实现了一个经纪人(Broker)构架，这意味着消息在发送给客户端时先在中心队列排队。
对路由(Routing)，负载均衡(Load balance)或者数据持久化都有很好的支持。
AMQP协议更多用在企业系统内，对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量还在其次。

## Redis

是一个Key-Value的NoSQL数据库，开发维护很活跃，虽然它是一个Key-Value数据库存储系统，
但它本身支持MQ功能，所以完全可以当做一个轻量级的队列服务来使用。
对于RabbitMQ和Redis的入队和出队操作，各执行100万次，每10万次记录一次执行时间。
测试数据分为128Bytes、512Bytes、1K和10K四个不同大小的数据。

实验表明：

入队时，当数据比较小时Redis的性能要高于RabbitMQ，而如果数据大小超过了10K，Redis则慢的无法忍受；
出队时，无论数据大小，Redis都表现出非常好的性能，而RabbitMQ的出队性能则远低于Redis。

## ZeroMQ

号称最快的消息队列系统，尤其针对大吞吐量的需求场景。ZMQ能够实现RabbitMQ不擅长的高级/复杂的队列，
但是开发人员需要自己组合多种技术框架，技术上的复杂度是对这MQ能够应用成功的挑战。
ZeroMQ具有一个独特的非中间件的模式，你不需要安装和运行一个消息服务器或中间件，
因为你的应用程序将扮演了这个服务角色。你只需要简单的引用ZeroMQ程序库，可以使用NuGet安装，
然后你就可以愉快的在应用程序之间发送消息了。但是ZeroMQ仅提供非持久性的队列，也就是说如果down机，数据将会丢失。

ZeroMQ只是一个封装了网络Socket编程的Pattern库，将常见的网络请求形式（分组管理，链接管理，发布订阅等）模式化、组件化，简而言之socket之上、MQ之下。

引用官方的说法： “ZMQ (以下 ZeroMQ 简称 ZMQ)是一个简单好用的传输层，
像框架一样的一个 socket library，他使得 Socket 编程更加简单、简洁和性能更高。
是一个消息处理队列库，可在多个线程、内核和主机盒之间弹性伸缩。
ZMQ 的明确目标是“成为标准网络协议栈的一部分，之后进入 Linux 内核”。现在还未看到它们的成功。
但是，它无疑是极具前景的、并且是人们更加需要的“传统”BSD 套接字之上的一层封装。ZMQ 让编写高性能网络应用程序极为简单和有趣。”

因此, ZeroMQ不是传统意义上的MQ。它比较适用于节点之间和节点与Master之间的通信。
Storm在0.8之前的Worker之间的通信就是通过ZeroMQ。但是为什么0.9就是用Netty替代了ZeroMQ呢？
说替代不大合适，只是0.9的默认的Worker之间的通信是使用了Netty，ZeroMQ还是支持的。Storm官方认为ZeroMQ有以下缺点：

* 不容易部署，尤其是在云环境下：以为ZMQ是以Ｃ写的，因此它还是紧依赖于操作系统环境的。
* 无法限制其内存。通过JVM可以很容易的限制java所占用的内存。但是ZMQ对于Storm来说是个黑盒似得存在。
* Storm无法从ZMQ获取信息。比如Storm无法知道当前buffer中有多少数据为发送。
* 当然了还有所谓的性能问题，具体可以访问Netty作者的blog。结论就是Netty的性能比ZMQ（在默认配置下）好两倍。
Netty使用Java实现的确方便了在Worker之间的通信加上授权和认证机制。这个使用ZMQ的确是不太好做。


## ActiveMQ

Apache下的一个子项目。 类似于ZeroMQ，它能够以代理人和点对点的技术实现队列。
同时类似于RabbitMQ，它少量代码就可以高效地实现高级应用场景。
RabbitMQ、ZeroMQ、ActiveMQ均支持常用的多种语言客户端 C++、Java、.Net,、Python、 Php、 Ruby等。

## Jafka/Kafka

Kafka是linkedin开源的MQ系统，是一个高性能跨语言分布式Publish/Subscribe消息队列系统，
而Jafka是在Kafka之上孵化而来的，即Kafka的一个升级版。具有以下特性：

* 快速持久化，可以在O(1)的系统开销下进行消息持久化；
* 高吞吐，在一台普通的服务器上既可以达到10W/s的吞吐速率；
* 完全的分布式系统，Broker、Producer、Consumer都原生自动支持分布式，自动实现复杂均衡；
* 支持Hadoop数据并行加载，对于像Hadoop的一样的日志数据和离线分析系统，但又要求实时处理的限制，这是一个可行的解决方案。Kafka通过Hadoop的并行加载机制来统一了在线和离线的消息处理。

Apache Kafka相对于ActiveMQ是一个非常轻量级的消息系统，除了性能非常好之外，还是一个工作良好的分布式系统。

一开始的目的就是用于日志收集和传输，0.8开始支持复制，不支持事务，适合产生大量数据的互联网服务的数据收集业务。
对于MQ来说，网络传输只是它的一部分，更多需要处理的是消息存储、路由、Broker服务发现和查找、事务、消费模式（ack、重投等）、集群服务等。


