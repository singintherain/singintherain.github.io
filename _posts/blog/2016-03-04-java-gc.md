---
layout: post
title: JVM GC
description: 总结JVM GC
category: blog
---

JVM采用分代策略做对象GC
新生代GC算法:标记-清除和复制两种算法
老年代：采用标记-整理算法

标记-清除算法会产生很多内存碎片, 标记和清除两个操作的效率都比较低
复制算法对存活率较高的对象做复制操作，效率比较低

所谓的大对象一般是指长的字符串和数组

## 判断对象是否已死

### 引用计数方法

给对象添加一个引用计数器，每当一个地方引用它时，计数器就加1；
当引用失效时，计数器就减1；任何时刻计数器为0的对象就是不能再被使用的。
但是这个解决不了循环引用的问题，循环引用的情形下，对象一直不能被回收。

### 可达性分析算法

通过一些称为"GC roots"对象作为起始点, 从这些节点向下搜索，搜索所走过的
路径就称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的
JVM中，可作为GC Roots的对象有：
虚拟机栈中引用的对象，方法区中类静态属性引用的对象，方法区中常量引用的对象，
本地方法栈中JNI引用的对象

JVM中是使用的可达性分析算法作为判断对象是否死去
但是即使达性分析出的对象并非非死不可，它必须经过两次标记过程：
如果对象在进行可达性分析后没有与GC Roots相连接的引用链，那它会被第一次标记并进行一次筛选
筛选的条件是此对象是否有必要执行finalize().当对象没有覆盖finalize,或者finalize已经被执行过，则虚拟机认为没有必要执行finalize
如果这个对象被认为需要执行finalize，那么这个对象将会被放置在队列中，并由finalizer线程执行它。
finalize方法只会被执行一次，用户可以在finalize方法中复活对象，但是对象会被多次回收，下一次回收时就不会再执行finalize方法,也就不会再被复活

## 内存分配和回收策略

在大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够的空间进行分配时，
虚拟机就发起Minor GC. Minor GC后，如果一个Survivor区不能完全保存剩余的对象，则根据
对象担保策略，则剩余对象全部进入老年代
大对象直接进入老年代
长期存活的对象进入老年代，在Survivor区中，每熬过一次minor gc，年龄就增加1，
当达到某一个阈值时，就被晋升到老年代

有三种方式进入老年代

FullGC 老年代GC,出现FullGC一般至少会伴随一次MinorGC，FullGC的速度一般比MinorGC
慢10倍以上。


