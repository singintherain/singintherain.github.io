---
layout: post
title: Redis使用
description: 浅析Redis使用中注意的事项
category: blog
---

## Redis是否需要做读写分离

Mysql做读写分离，是因为可以根据读写两个操作定义不同的事务隔离级别，
不同的事务隔离级别使用了不同的锁策略，而不同的锁策略极大的影响了响应性能

## Redis的Expire

Redis的Expier只能针对键失效, 不能针对于具体的值失效.
例如，数据结构类型是set（key-name value), 可以expire key-name time
但是如果数据结构类型是Map(key-name key value), 只能针对key-name失效，key-name失效时，这个key-name下面的所有数据就会被删除
list/set/zset也一样

### 如何针对值做expire?

在value中保存新建时间，每次做读取操作的时候根据保存的时间和当前时间做判断

## Redis的连接

Redis服务器采用事件触发异步非阻塞的方式响应客户端连接，为每个连接打开一个通信socket资源。
默认情况下服务器不会主动关闭连接链路，除非客户端主动的断开连接。
但是可以在后台配置一个时间窗口，针对idle链接（时间窗口内一直没有通信数据传输, 用户没有关闭过)做删除

## 水平切分

### 为什么需要水平切分

* 扩展数据库容量
* 增大计算能力

实际应用中，更明显的好处是，解决了写操作单点问题；写操作一般比较耗时，尤其是当只有
一个节点做写操作时（使用主从分离是解决读写分离问题)，将写操作分担到不同的节点，可以提高
服务响应时间。

### 切分算法

* 区间
* 哈希

一致性哈希，和普通哈希相比，能够更好的做负载均衡；
假设有N个处理节点，在普通哈希算法下，Hash(Key) mode N，找指定的处理节点；但是这种策略下，
如果处理节点个数发生了变更，成了N-1，则原来处理对应所有Key的处理节点完全发生改变;
例如，开始将Key对应的数据写到了Node1，但是后来处理节点变更，造成后续的Key的数据查询落到了
Node2，使得查询失败，数据失效，这是不允许的；
在一致性哈希中，对Key做哈希Hash(key) mode M，同时对节点的某些唯一性标识做哈希Hash(mac_address) mode M,
M代表Hash函数的值空间，即肯定会落在(0..M)之间;然后使用Key的结果V依次往后在(V..M)中查询现有
的处理节点，碰到的第一个节点就为处理节点.这种算法能够保证，当某个节点退出时，会减小影响范围。
例如，当前节点有4-7-8，Key1的处理节点现在为7,当节点7被删除时，Key1的节点就变为8，这是会
出现处理失效的现象；但是此时只会影响处理节点为7的所有Key，其他的Key不受任何影响, 例如Key2
的处理节点为4，当7退出时，Key2的处理节点仍然为4

### 实现方式

实际上Redis的水平切分和Mysql的水平切分原理都一样, 有三种方法做水平切分

- 客户端划分

客户端通过指定的key直接选择合适的节点

- 代理辅助划分

客户端连接代理，代理和Redis实例通信; 在代理中配置请求转发策略，将请求发给配置的Redis实例；
Twemproxy就是典型代理辅助划分的实现。

- 查询路由切分

将query随机发送给一个Redis实例，这个Redis实例可以将请求转发到正确的处理节点(并不是请求
从一个Redis实例转发到另一个，而是将客户端重定向到正确的节点)

### 水平切分的缺点

* 一次命中多个Key的操作不支持，例如如果使用key被映射到不同的Redis实例, 对两个set做交操作
是不被允许的
* 不支持关联多个Key的事务
* 如果做了水平切分，会使得一些数据操作比较复杂；例如为了持久化数据，需要聚集多个实例
的RDB/AOF文件
* 增加和删除实例比较复杂。在Redis Cluster中增删节点时可以做到透明的数据负载均衡。
但是像其他的客户端切分或者代理都不支持这项功能。但是有个pre-sharding可以解决这个问题.

### Jedis

Jedis提供了在客户端提供sharding的机制，默认是走的Hash算法
在使用Jedis时，需要提供多个sharding配置

## 分布式锁

需要特定的客户端提供分布式锁机制

### 安全性和存活性保证

* 安全性：互斥排他性；在任何时刻，只能有一个客户端能够拿到锁
* 存活性：死锁free；如果锁定资源的客户端崩溃了或者被水平切分了，最终也是能够获得锁
* 存活性：错误容忍；只要有Redis的主节点存活，客户端就一定能够获取锁

### 为什么基于容错机制的锁是不完善的

用Redis锁定一个资源最简单的方法，就是在一个实例中生成一个key；这个key有过期时间。
当客户端想释放资源时，可以删除这个key。
但是，上面的机制有个弱点，就是单点失败。当保存key的主节点宕机了，怎么办？
ok，针对上述问题，可以通过增加从库的方式解决。但是使用主从方式仍然有问题，主从数据同步
是异步的，有延迟。考虑下面的情况：

* 客户A在主节点拿到了锁
* 在这个key同步到从库之前，主库宕机了
* 从库替换了主库
* 客户B为资源申请相同的锁，可以成功。安全性缺陷

### Redis主从

使用Sentinal哨兵机制做Redis Master-Slave切换，启动多个哨兵使用心跳机制监控Master存活状况，使用投票裁决方式决定一个Master是否可用。

## Redis Cluster

Redis在3.0之后增加了对Cluster的支持

所谓的槽位就是指区间, 而且并不是每个槽位都对应一个key，crc16(key) % 槽位总和，求得这个key对应的槽位

Redis集群混合了查询路由和客户端水平切分技术

Redis打开两个端口，一般6379端口来响应客户端的连接，16379(10000+6379)处理Redis节点
之间的通信

### Sharding

Cluster的Sharding不是用一致性Hash做的,而是用Slot(槽位)分配来做的

客户端感知不到shards的动态变化，很难做到动态的sharding

Cluster模式下，读写是不是只能用到主节点，不能用到从节点
槽位都是预先分配好的，如果这时动态在集群中添加了一个节点，应该怎么分配槽位; 在集群中动态的添加和删除节点时，会预先执行哈希槽转移操作，将原有的数据转到别的节点；槽位转移时，也会将槽位里的数据同时转移到新节点



